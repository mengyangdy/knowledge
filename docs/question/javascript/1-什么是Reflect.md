# 1.什么是Reflect有什么作用？

reflect也就是反射的意思，它的唯一作用就是可以完成对象的基本操作

**什么是对象的基本操作？**

我们JS里面有对象，函数也是对象，我们创建的对象也是对象，对于对象我们有很多的操作，比如说增删改查，`obj.a=1,delete obj.a`等操作，我们还可以设置对象的原型，读取对象的原型，这些都是对对象的操作

我们无论是用语法来操作对象，还是用函数来操作对象，他们都在直接或间接的完成对象的基本操作

在ES-262的文档里面，他认为我们对一个对象一共就这些操作，这些操作无法被分割，这些就是基本操作，这些方法都是内部方法，不暴露在外的，这些操作是语言层面上规定好的，当时我们是无法直接使用这些基本操作的，至少在以前浏览器是不给我们使用的，我们只能间接的使用这些方法，比如说obj.a=1,使用的是[[set]]方法

一般情况下，使用间接方法是没有问题的，但是可能会导致无法预料的bug，比如说Object.keys,它会获取对象的可枚举的键对，如果我们给对象上添加一个不可枚举的值，他是拿不到的，当时如果我想想拿到这个值呢？就是用Reflect，它的作用就是调用对象的基本方法

我们像得到一个对象的所有key值，我们就可以使用Reflect.ownKeys获取到所有的键对

还有一个场景：

```js
const obj={
	a:1,
	b:2,
	get c(){
		console.log(this)
		return this.a+this.b
	}
}
console.log(obj.c)// this是obj 我们没有传递this为什么就有this了？浏览器默认给我们添加上了

const handle=new Proxy(obj,{
	get(target,key,receiver){
		console.log(key)
		return target[key]
	}
})

handle.c// get里面只会打印c 它拦截不到a和b
```

我们使用Reflect可以直接传递this，不需要浏览器给我们默认添加，我们这里也可以灵活性的修改this

在vue3的源码中，我们使用proxy来对对象进行代理，他有一个问题就是间接属性我们是拦截不到的因为它的this还是指向了原对象，而不是通过我们的proxy对象来读取的，所以我们proxy对象的get拦截不到其他的属性，如果我们使用Reflect.get(target,key,receiver)就可以拦截到了
